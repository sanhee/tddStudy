# 테스트 주도 개발 시작하기



## 2장



### 암호 검사기 (TDD 실습)



- 문자열을 검사해서 규칙을 준수하는지에 따라 암호를 `약함`, `보통`, `강함`으로 구분
- 검사할 규칙은 다음 세 가지
  - 길이가 8글자 이상
  - 0부터 9 사이의 숫자를 포함
  - 대문자 포함
- 세 규칙을 모두 충족하면 암호는 `강함`
- 2개의 규칙을 충족하면 암호는 `보통`
- 1개 이하의 규칙을 충족하면 암호는 `약함`



### 첫 번째 테스트: 모든 규칙을 충족하는 경우

- 첫 번째 테스트를 선택할 때에는 가장 쉽거나 가장 예외적인 상황을 선택해야한다.



### 테스트 코드 정리

- 테스트 코드도 코드이기 때문에 유지보수 대상이다.

- 즉, 테스트 메서드에서 발생하는 중복을 알맞게 제거하거나 의미가 잘 드러나게 코드를 수정할 필요가 있다.
- 테스트 코드의 중복을 무턱대고 제거하면 안 된다. 중복을 제거한 뒤에도 **테스트 코드의 가독성이 떨어지지 않고 수정이 용이한 경우**에만 중복을 제거해야한다.
  - 중복을 제거한 뒤에 오히려 테스트 코드 관리가 어려워진다면 제거했던 중복을 되돌려야 한다.



### isBlank() vs isEmpty()

```java
public class Main 
{
    public static void main(String[] args) 
    {
        System.out.println( "ABC".isBlank() );      //false
        System.out.println( "  ".isBlank() );       //true
 
        System.out.println( "ABC".isEmpty() );      //false
        System.out.println( "  ".isEmpty() );       //false
    }
}
```

- https://howtodoinjava.com/java11/check-blank-string/



### (내가 실수한 부분 노트) 앞서서 생각하지 말자



다른 예외까지 처리하려고 하는데.. 지금 당장은 테스트케이스만 통과되도록 코드를 작성하자.

고민했던 건 아래 코드인데,

```java
if(!lengthEnough){
    return PasswordStrength.NORMAL;
}
```

**!길이 and (!숫자 또는 !대문자) 일 경우 WEAK에 대한 예외가 안돼있어서 처리해줘야 하나? 였음**



하지만, 당시 작성중이었던 테스트 코드는 `길이가 8글자 이상인 조건만 충족하는 경우` 였으므로, 

위 예외는 생각할 필요가 없음.



즉, 지금은 이 부분만 작성해주면 됨

```java
if(lengthEnough && !containNum && !containUppercase){
	return PasswordStrength.WEAK;
}
```



### 정리

- TDD 사이클은 `Red-Green-Refactor`
  - 레드는 실패하는 테스트

- 테스트가 개발을 주도

  - 테스트를 작성하는 과정에서 구현을 생각하지 않음
    - 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만듬
  - 테스트를 통과시킬 만큼 기능을 구현
    - 아직 추가하지 않은 테스트를 고려해서 구현하지 않음

- TDD 이점

  1. 온전하게 동작한다는 것을 `검증`해주는 테스트가 있으므로 코드 수정에 대한 `심리적 불안감`을 줄여준다.

  2. 지속적으로 코드 정리를 하므로, 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있음
     - 향후 유지보수 비용을 낮추는데 기여

  3. 피드백이 빠르다.
     - 새로운 코드를 추가하거나, 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인할 수 있
       - 잘못된 코드가 배포되는 것을 방지



---



## 3장



### 지속적인 리팩토링

- 일단 동작하는 코드를 만드는 능력은 중요하다. 코드가 동작하지 않으면 아무것도 소용 없기 때문이다.
- 하지만, `소프트웨어 생존 시간`이 길어질수록 소프트웨어를 지속적으로 `개선`해야 한다.
  - 즉, 코드를 변경해야 한다.
  - 코드 변경이 어려우면 변화하는 여구를 제때 반영할 수 없게 되며, 이는 소프트웨어의 생존과 직결된다.
- 따라서 코드를 잘 변경할 수 있는 능력 또한 매우 중요하다.
  - 코드를 잘 변경하려면, `변경하기 쉬운 구조`를 가져야 하는데 이를 위한 것이 바로 `리팩토링`이다.



### 3장. 정기 유료 서비스 만료일 결정 (TDD 실습)

- [x] 서비스를 사용하려면 매달 1만원을 선불로 납부한다.
- [x] 2개월 이상 요금을 납부할 수 있다.
- [x] 10만 원을 납부하면 서비스를 1년 제공한다.



#### 실습 후기

- 요구사항은 단순 3 가지 이지만, 그외 생각 해야할 예외 케이스의 도출은 연습이 많이 필요한 것 같다.
  - 책에 있는 케이스들을 따라해보았지만, 요구사항만 주고 혼자서 해보라 하면 글쎄..아직은 많이 어색하다.

- 아주 작은 단위인 1만원 로직부터 시작해서 예외 상황 처리 해주면서 개발해가는 방식이 인상 깊었다.
- 리팩토링을 할 때, 기존 코드를 바로 수정하는 게 아니라 새로운 코드를 추가한 뒤, 호출 방식으로 정상 동작 하는지 확인 한뒤에 인라인 처리하는 게 인상깊었다.



### 테스트할 목록 정리

- TDD를 시작할 때, 테스트할 목록을 미리 정리하면 좋다.
  - 그중 구현이 쉬울 테스트가 무엇일지 상상한다.
  - 테스트 과정에서 새로운 테스트 사례를 발견하면 즉시 목록 업데이트
- 테스트 목록을 적었다고 해서, 테스트를 한 번에 다 작성하면 안된다.
  - 한 번에 작성한 테스트 코드가 많으면 구현 초기에도 리팩토링을 마음 껏 못하게 된다.
    - 모든 테스트를 통과시키기 전까지는 계속해서 깨지는 테스트가 존재하므로, `개발리듬`을 유지 하는 데 도움이 안된다.
- 하나의 테스트 코드를 만들고 이를 통과시키고, 리랙토링하고.. 짧은 리듬을 반복
- 개발을 진행하다 보면 변경 범위가 매우 큰 리팩토링 거리를 발견할 때도 있다.
  - TDD 흐름을 깨기 쉬우므로, 리팩토링 진행을 미뤄두고, 테스트를 통과하는데 집중한다.



### 시작이 안될 때는 단언부터 고민

- 테스트 코드를 작성하다 보면 시작이 잘 안될 때가 있다.

  - 이럴 땐 `검증하는 코드부터` 작성

    - 예를 들어 만료일 계산 기능의 경우 만료일을 검증하는 코드부터 작성

      ```java
      @Test
      void 만원_납부하면_한달_뒤가_만료일이_됨(){
        // 처음 작성하는 코드
        assertEquals(기대하는 만료일, 실제 만료일);
      }
      ```

      

### 구현이 막히면

- 과감하게 코드를 지우고 미련없이 다시 시작
- 어떤 순서로 작성했는 지 되돌아보고, 순서를 바꿔 다시 진행
- 상기할 것
  - 쉬운 테스트, 예외적인 테스트
  - 완급 조절



## 4장. TDD 기능 명세·설계



### 기능 명세

- 기능은 크게 `입력`과 `결과`로 나뉜다.
- 설계는 기능 명세로부터 시작
- 요구사항 문서를 이용해서 기능 명세 구체화
  - 구체화하는 동안 `입력`과 `결과` 도출
  - 도출한 기능 명세를 코드에 반영
    - 기능의 이름, 파라미터, 리턴 타입 등 결정됨

### 설계 과정을 지원하는 TDD

- 테스트 코드를 만들기 위해 필요한 것
  1. 테스트에서 실행할 수 있는 객체나 함수의 존재
  2. 실행 결과를 검증
- 테스트 코드를 작성하는 과정에서 네 가지가 결정됨
  1. 클래스 이름
  2. 메서드 이름
  3. 메서드 파라미터
  4. 실행 결과
- TDD 자체가 설계는 아니지만, 설계 과정에서 고민하는 것과 겹치는 부분 존재



### 필요한 만큼 설계

- 설계가 불필요하게 복잡해지는 것을 방지



### 기능 명세 구체화

- 요구사항 명세에는 개발자가 기능을 구현하기에 생략된 내용이 많다.
- 실무 담당자와 얘기해서 상황에 따라 기능이 어떻게 동작하는지 구체적으로 정리해야 한다.
