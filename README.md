# 테스트 주도 개발 시작하기



## 2장



### 암호 검사기 (TDD 실습)



- 문자열을 검사해서 규칙을 준수하는지에 따라 암호를 `약함`, `보통`, `강함`으로 구분
- 검사할 규칙은 다음 세 가지
  - 길이가 8글자 이상
  - 0부터 9 사이의 숫자를 포함
  - 대문자 포함
- 세 규칙을 모두 충족하면 암호는 `강함`
- 2개의 규칙을 충족하면 암호는 `보통`
- 1개 이하의 규칙을 충족하면 암호는 `약함`



### 첫 번째 테스트: 모든 규칙을 충족하는 경우

- 첫 번째 테스트를 선택할 때에는 가장 쉽거나 가장 예외적인 상황을 선택해야한다.



### 테스트 코드 정리

- 테스트 코드도 코드이기 때문에 유지보수 대상이다.

- 즉, 테스트 메서드에서 발생하는 중복을 알맞게 제거하거나 의미가 잘 드러나게 코드를 수정할 필요가 있다.
- 테스트 코드의 중복을 무턱대고 제거하면 안 된다. 중복을 제거한 뒤에도 **테스트 코드의 가독성이 떨어지지 않고 수정이 용이한 경우**에만 중복을 제거해야한다.
  - 중복을 제거한 뒤에 오히려 테스트 코드 관리가 어려워진다면 제거했던 중복을 되돌려야 한다.



### isBlank() vs isEmpty()

```java
public class Main 
{
    public static void main(String[] args) 
    {
        System.out.println( "ABC".isBlank() );      //false
        System.out.println( "  ".isBlank() );       //true
 
        System.out.println( "ABC".isEmpty() );      //false
        System.out.println( "  ".isEmpty() );       //false
    }
}
```

- https://howtodoinjava.com/java11/check-blank-string/



### (내가 실수한 부분 노트) 앞서서 생각하지 말자



다른 예외까지 처리하려고 하는데.. 지금 당장은 테스트케이스만 통과되도록 코드를 작성하자.

고민했던 건 아래 코드인데,

```java
if(!lengthEnough){
    return PasswordStrength.NORMAL;
}
```

**!길이 and (!숫자 또는 !대문자) 일 경우 WEAK에 대한 예외가 안돼있어서 처리해줘야 하나? 였음**



하지만, 당시 작성중이었던 테스트 코드는 `길이가 8글자 이상인 조건만 충족하는 경우` 였으므로, 

위 예외는 생각할 필요가 없음.



즉, 지금은 이 부분만 작성해주면 됨

```java
if(lengthEnough && !containNum && !containUppercase){
	return PasswordStrength.WEAK;
}
```



### 정리

- TDD 사이클은 `Red-Green-Refactor`
  - 레드는 실패하는 테스트

- 테스트가 개발을 주도

  - 테스트를 작성하는 과정에서 구현을 생각하지 않음
    - 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만듬
  - 테스트를 통과시킬 만큼 기능을 구현
    - 아직 추가하지 않은 테스트를 고려해서 구현하지 않음

- TDD 이점

  1. 온전하게 동작한다는 것을 `검증`해주는 테스트가 있으므로 코드 수정에 대한 `심리적 불안감`을 줄여준다.

  2. 지속적으로 코드 정리를 하므로, 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있음
     - 향후 유지보수 비용을 낮추는데 기여

  3. 피드백이 빠르다.
     - 새로운 코드를 추가하거나, 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인할 수 있
       - 잘못된 코드가 배포되는 것을 방지



---



## 3장



### 지속적인 리팩토링

- 일단 동작하는 코드를 만드는 능력은 중요하다. 코드가 동작하지 않으면 아무것도 소용 없기 때문이다.
- 하지만, `소프트웨어 생존 시간`이 길어질수록 소프트웨어를 지속적으로 `개선`해야 한다.
  - 즉, 코드를 변경해야 한다.
  - 코드 변경이 어려우면 변화하는 여구를 제때 반영할 수 없게 되며, 이는 소프트웨어의 생존과 직결된다.
- 따라서 코드를 잘 변경할 수 있는 능력 또한 매우 중요하다.
  - 코드를 잘 변경하려면, `변경하기 쉬운 구조`를 가져야 하는데 이를 위한 것이 바로 `리팩토링`이다.



### 3장. 정기 유료 서비스 만료일 결정 (TDD 실습)

- [x] 서비스를 사용하려면 매달 1만원을 선불로 납부한다.
- [x] 2개월 이상 요금을 납부할 수 있다.
- [x] 10만 원을 납부하면 서비스를 1년 제공한다.



```
책 보기전 내가 생각하는 테스트케이스 순서

1. 10만 원을 납부하면 서비스를 1년 +
2. 2만 원을 지불하면 2개월 +
3. 1만 원을 지불하면 서비스 제공 X 
   - 2개월 이상 납부
4. 윤년 계산? LocalDate 쓰면 자동으로 될 것 같긴한대..
```

